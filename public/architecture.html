<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent Architecture â€” Agent Portal</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0f;
      --surface: rgba(255,255,255,0.04);
      --surface-hover: rgba(255,255,255,0.07);
      --border: rgba(255,255,255,0.08);
      --text: #e4e4e7;
      --text-muted: #71717a;
      --text-dim: #52525b;
      --accent: #818cf8;
      --accent-dim: rgba(129,140,248,0.15);
      --green: #34d399;
      --green-dim: rgba(52,211,153,0.15);
      --yellow: #fbbf24;
      --yellow-dim: rgba(251,191,36,0.15);
      --red: #f87171;
      --red-dim: rgba(248,113,113,0.15);
      --blue: #60a5fa;
      --blue-dim: rgba(96,165,250,0.15);
      --purple: #a78bfa;
      --purple-dim: rgba(167,139,250,0.15);
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: 'Inter', system-ui, sans-serif; 
      background: var(--bg); 
      color: var(--text); 
      min-height: 100vh; 
      overflow: hidden;
    }

    /* Header & Navigation */
    header {
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid var(--border);
      position: sticky; 
      top: 0; 
      z-index: 100;
      background: rgba(10,10,15,0.95); 
      backdrop-filter: blur(12px);
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    
    .logo { 
      font-size: 1.1rem; 
      font-weight: 600; 
      display: flex; 
      align-items: center; 
      gap: 0.5rem;
    }
    
    .logo a {
      color: var(--text);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .logo a:hover {
      color: var(--accent);
    }
    
    .nav-links {
      display: flex;
      gap: 0.25rem;
    }
    
    .nav-link {
      font-size: 0.85rem;
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      color: var(--text-muted);
      text-decoration: none;
      transition: all 0.15s;
      font-weight: 500;
    }
    
    .nav-link:hover {
      background: var(--surface-hover);
      color: var(--text);
    }
    
    .nav-link.active {
      background: var(--accent-dim);
      color: var(--accent);
    }
    
    .header-right { 
      display: flex; 
      align-items: center; 
      gap: 0.75rem; 
    }
    
    .conn { 
      font-size: 0.7rem; 
      color: var(--text-dim); 
      display: flex; 
      align-items: center; 
      gap: 0.35rem; 
    }
    
    .conn .dot { 
      width: 6px; 
      height: 6px; 
      border-radius: 50%; 
      background: var(--text-dim); 
    }
    
    .conn.live .dot { 
      background: var(--green); 
      box-shadow: 0 0 6px var(--green); 
    }
    
    .conn.live { color: var(--text-muted); }
    
    .user { 
      display: flex; 
      align-items: center; 
      gap: 0.5rem; 
    }
    
    .user img { 
      width: 28px; 
      height: 28px; 
      border-radius: 50%; 
    }
    
    .user span { 
      font-size: 0.8rem; 
      color: var(--text-muted); 
    }
    
    .btn-s { 
      font-size: 0.75rem; 
      padding: 0.3rem 0.6rem; 
      border-radius: 6px; 
      border: 1px solid var(--border); 
      background: transparent; 
      color: var(--text-muted); 
      cursor: pointer; 
      text-decoration: none;
      display: inline-block;
    }
    
    .btn-s:hover { 
      background: var(--surface-hover); 
      color: var(--text); 
    }

    /* Main canvas container */
    .canvas-container {
      position: relative;
      width: 100%;
      height: calc(100vh - 49px);
      overflow: hidden;
      background: var(--bg);
    }
    
    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .connections line {
      stroke: var(--border);
      stroke-width: 2;
      opacity: 0.5;
    }
    
    .connections line.active {
      stroke: var(--accent);
      opacity: 0.8;
      stroke-dasharray: 5 5;
      animation: dash 1s linear infinite;
    }
    
    @keyframes dash {
      to { stroke-dashoffset: -10; }
    }

    /* Node cards */
    .node {
      position: absolute;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      min-width: 200px;
      max-width: 280px;
      pointer-events: auto;
      cursor: move;
      transition: transform 0.15s, box-shadow 0.15s;
      user-select: none;
    }
    
    .node:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    }
    
    .node.active {
      border-color: var(--green);
      box-shadow: 0 0 20px var(--green-dim);
      animation: pulse 2s ease-in-out infinite;
    }
    
    .node.idle {
      border-color: var(--border);
      opacity: 0.7;
    }
    
    .node.error {
      border-color: var(--red);
      box-shadow: 0 0 20px var(--red-dim);
    }
    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 20px var(--green-dim); }
      50% { box-shadow: 0 0 30px var(--green-dim), 0 0 40px var(--green-dim); }
    }
    
    .node-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.75rem;
    }
    
    .node-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 0.25rem;
    }
    
    .node-subtitle {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
    }
    
    .node-status {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    
    .node-status.active {
      background: var(--green);
      box-shadow: 0 0 8px var(--green);
    }
    
    .node-status.idle {
      background: var(--text-dim);
    }
    
    .node-status.error {
      background: var(--red);
      box-shadow: 0 0 8px var(--red);
    }
    
    .node-meta {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.5rem 0.75rem;
      font-size: 0.75rem;
    }
    
    .node-meta-label {
      color: var(--text-dim);
    }
    
    .node-meta-value {
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      text-align: right;
    }
    
    .node-progress {
      margin-top: 0.75rem;
      height: 4px;
      background: var(--surface);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .node-progress-bar {
      height: 100%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.3s ease;
    }
    
    .node-task {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 0.5rem;
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Primary agent node styling */
    .node.primary {
      min-width: 260px;
      background: linear-gradient(135deg, rgba(129,140,248,0.08), rgba(167,139,250,0.08));
      border-color: var(--accent);
    }
    
    /* User node styling */
    .node.user {
      min-width: 180px;
      background: linear-gradient(135deg, rgba(96,165,250,0.08), rgba(52,211,153,0.08));
      border-color: var(--blue);
    }
    
    /* SLM node styling */
    .node.slm {
      min-width: 220px;
      background: linear-gradient(135deg, rgba(251,191,36,0.08), rgba(248,113,113,0.08));
      border-color: var(--yellow);
    }
    
    .slm-models {
      margin-top: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    
    .slm-model {
      font-size: 0.7rem;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-muted);
      padding: 0.25rem 0.5rem;
      background: var(--surface);
      border-radius: 4px;
    }
    
    .slm-model.active {
      color: var(--yellow);
      background: var(--yellow-dim);
      border: 1px solid var(--yellow);
    }

    /* Legend */
    .legend {
      position: absolute;
      bottom: 1.5rem;
      right: 1.5rem;
      background: rgba(10,10,15,0.95);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      font-size: 0.75rem;
      backdrop-filter: blur(12px);
      z-index: 50;
    }
    
    .legend-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text);
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.35rem 0;
      color: var(--text-muted);
    }
    
    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    /* Loading state */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: var(--text-muted);
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <div class="logo">
        <a href="/">ðŸ¦ž Talos</a>
      </div>
      <nav class="nav-links">
        <a href="/dashboard" class="nav-link">Dashboard</a>
        <a href="/architecture" class="nav-link active">Architecture</a>
      </nav>
    </div>
    <div class="header-right">
      <div class="conn" id="ws-status">
        <div class="dot"></div>
        <span>Connecting...</span>
      </div>
      <div class="user" id="user-info"></div>
      <a href="/auth/logout" class="btn-s" style="text-decoration: none;">Logout</a>
    </div>
  </header>

  <div class="canvas-container" id="canvas">
    <div class="loading" id="loading">
      <div class="spinner"></div>
      <div>Loading architecture...</div>
    </div>
    
    <svg id="connections">
      <g class="connections"></g>
    </svg>
    
    <div id="nodes"></div>
  </div>

  <div class="legend">
    <div class="legend-title">Status</div>
    <div class="legend-item">
      <div class="legend-dot" style="background: var(--green); box-shadow: 0 0 6px var(--green);"></div>
      <span>Active</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: var(--text-dim);"></div>
      <span>Idle</span>
    </div>
    <div class="legend-item">
      <div class="legend-dot" style="background: var(--red); box-shadow: 0 0 6px var(--red);"></div>
      <span>Error</span>
    </div>
  </div>

  <script>
    // State
    let ws = null;
    let nodes = {};
    let draggedNode = null;
    let dragOffset = { x: 0, y: 0 };

    // Initialize
    async function init() {
      await fetchUser();
      await fetchArchitecture();
      initWebSocket();
      initDragAndDrop();
      document.getElementById('loading').style.display = 'none';
    }

    // Fetch user info
    async function fetchUser() {
      try {
        const res = await fetch('/api/me');
        const user = await res.json();
        if (user) {
          const userEl = document.getElementById('user-info');
          userEl.innerHTML = user.picture 
            ? `<img src="${user.picture}" alt="${user.name}"><span>${user.name}</span>`
            : `<span>${user.name}</span>`;
        }
      } catch (err) {
        console.error('Failed to fetch user:', err);
      }
    }

    // Fetch architecture data
    async function fetchArchitecture() {
      try {
        const res = await fetch('/api/architecture');
        const data = await res.json();
        renderArchitecture(data);
      } catch (err) {
        console.error('Failed to fetch architecture:', err);
        document.getElementById('loading').innerHTML = '<div style="color: var(--red);">Failed to load architecture</div>';
      }
    }

    // Render architecture
    function renderArchitecture(data) {
      const container = document.getElementById('nodes');
      const svg = document.querySelector('.connections');
      
      // Clear existing
      container.innerHTML = '';
      svg.innerHTML = '';
      nodes = {};

      const width = window.innerWidth;
      const height = window.innerHeight - 49;
      const centerX = width / 2;
      const centerY = height / 2;

      // User node (top left)
      createNode('user', {
        type: 'user',
        title: 'Toby',
        subtitle: 'Human',
        status: 'active',
        x: centerX - 400,
        y: centerY - 200
      });

      // Primary agent (center)
      createNode('primary', {
        type: 'primary',
        title: data.primaryAgent.name,
        subtitle: data.primaryAgent.model,
        status: data.primaryAgent.status,
        meta: {
          'Uptime': data.primaryAgent.uptime,
          'Context': `${formatNumber(data.primaryAgent.contextUsed)} / ${formatNumber(data.primaryAgent.contextMax)}`
        },
        progress: (data.primaryAgent.contextUsed / data.primaryAgent.contextMax) * 100,
        x: centerX,
        y: centerY
      });

      // Sub-agents (arranged in circle around primary)
      const subAgentCount = data.subAgents.length;
      const radius = 300;
      data.subAgents.forEach((sub, i) => {
        const angle = (i / Math.max(subAgentCount, 1)) * Math.PI * 2 - Math.PI / 2;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        // Map status to visual state
        let visualStatus = 'idle';
        if (sub.status === 'running' || sub.status === 'pending') visualStatus = 'active';
        else if (sub.status === 'failed' || sub.status === 'stale') visualStatus = 'error';
        else if (sub.status === 'completed') visualStatus = 'idle';
        
        createNode(`sub-${i}`, {
          type: 'subagent',
          title: sub.label || `Sub-agent #${i + 1}`,
          subtitle: sub.model,
          status: visualStatus,
          task: sub.task,
          meta: {
            'Runtime': sub.runtime,
            'Tokens': formatNumber(sub.tokens)
          },
          x,
          y
        });
      });

      // SLM node (ISSUE 3 FIX: always show if models exist OR if active)
      if (data.slm && (data.slm.models.length > 0 || data.slm.status === 'active')) {
        createNode('slm', {
          type: 'slm',
          title: 'Ollama',
          subtitle: 'Local SLM',
          status: data.slm.status,
          models: data.slm.models,
          activeModel: data.slm.activeModel,
          x: centerX + 400,
          y: centerY + 200
        });
      }

      // Draw connections
      drawConnections(data.connections);
    }

    // Create a node
    function createNode(id, config) {
      const node = document.createElement('div');
      node.className = `node ${config.type} ${config.status}`;
      node.id = `node-${id}`;
      node.style.left = `${config.x - 100}px`;
      node.style.top = `${config.y - 60}px`;
      
      let html = `
        <div class="node-header">
          <div>
            <div class="node-title">${config.title}</div>
            <div class="node-subtitle">${config.subtitle}</div>
          </div>
          <div class="node-status ${config.status}"></div>
        </div>
      `;
      
      if (config.meta) {
        html += '<div class="node-meta">';
        for (const [key, value] of Object.entries(config.meta)) {
          html += `<div class="node-meta-label">${key}:</div><div class="node-meta-value">${value}</div>`;
        }
        html += '</div>';
      }
      
      if (config.progress !== undefined) {
        html += `
          <div class="node-progress">
            <div class="node-progress-bar" style="width: ${config.progress}%"></div>
          </div>
        `;
      }
      
      if (config.task) {
        html += `<div class="node-task">${config.task}</div>`;
      }
      
      if (config.models) {
        html += '<div class="slm-models">';
        config.models.forEach(model => {
          const isActive = model === config.activeModel;
          html += `<div class="slm-model ${isActive ? 'active' : ''}">${model}</div>`;
        });
        html += '</div>';
      }
      
      node.innerHTML = html;
      document.getElementById('nodes').appendChild(node);
      
      nodes[id] = {
        element: node,
        x: config.x,
        y: config.y
      };
    }

    // Calculate intersection point of line with rectangle edge
    function getEdgeIntersection(x1, y1, x2, y2, nodeElement) {
      const rect = nodeElement.getBoundingClientRect();
      const nodeX = parseFloat(nodeElement.style.left) + rect.width / 2;
      const nodeY = parseFloat(nodeElement.style.top) + rect.height / 2;
      
      // Calculate intersection with rectangle boundary
      const dx = x2 - x1;
      const dy = y2 - y1;
      
      // Half dimensions
      const hw = rect.width / 2;
      const hh = rect.height / 2;
      
      // Find intersection point
      let t = 1;
      if (Math.abs(dx) > 0.001) {
        const tx = dx > 0 ? hw / dx : -hw / dx;
        if (tx < t) t = tx;
      }
      if (Math.abs(dy) > 0.001) {
        const ty = dy > 0 ? hh / dy : -hh / dy;
        if (ty < t) t = ty;
      }
      
      return {
        x: nodeX + dx * t,
        y: nodeY + dy * t
      };
    }

    // Draw connections between nodes (ISSUE 4 FIX: connect to edges, not centers)
    function drawConnections(connections) {
      const svg = document.querySelector('.connections');
      
      connections.forEach(conn => {
        const fromNode = nodes[conn.from];
        const toNode = nodes[conn.to];
        
        if (!fromNode || !toNode) return;
        
        // Get actual center positions
        const fromRect = fromNode.element.getBoundingClientRect();
        const toRect = toNode.element.getBoundingClientRect();
        
        const fromCenterX = fromNode.x;
        const fromCenterY = fromNode.y;
        const toCenterX = toNode.x;
        const toCenterY = toNode.y;
        
        // Calculate edge intersection points
        const fromEdge = getEdgeIntersection(fromCenterX, fromCenterY, toCenterX, toCenterY, fromNode.element);
        const toEdge = getEdgeIntersection(toCenterX, toCenterY, fromCenterX, fromCenterY, toNode.element);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', fromEdge.x);
        line.setAttribute('y1', fromEdge.y);
        line.setAttribute('x2', toEdge.x);
        line.setAttribute('y2', toEdge.y);
        
        // Active connections get animation
        const fromStatus = fromNode.element.classList.contains('active');
        const toStatus = toNode.element.classList.contains('active');
        if (fromStatus || toStatus) {
          line.classList.add('active');
        }
        
        svg.appendChild(line);
      });
    }

    // Drag and drop
    function initDragAndDrop() {
      const canvas = document.getElementById('canvas');
      
      canvas.addEventListener('mousedown', e => {
        if (e.target.closest('.node')) {
          draggedNode = e.target.closest('.node');
          const rect = draggedNode.getBoundingClientRect();
          dragOffset.x = e.clientX - rect.left;
          dragOffset.y = e.clientY - rect.top;
        }
      });
      
      canvas.addEventListener('mousemove', e => {
        if (draggedNode) {
          const x = e.clientX - dragOffset.x;
          const y = e.clientY - dragOffset.y;
          draggedNode.style.left = `${x}px`;
          draggedNode.style.top = `${y}px`;
          
          // Update stored position
          const nodeId = draggedNode.id.replace('node-', '');
          if (nodes[nodeId]) {
            nodes[nodeId].x = x + 100;
            nodes[nodeId].y = y + 60;
          }
          
          // Redraw connections
          document.querySelector('.connections').innerHTML = '';
          // Reconstruct connections from current state
          const connections = [];
          connections.push({ from: 'user', to: 'primary' });
          Object.keys(nodes).forEach(id => {
            if (id.startsWith('sub-')) {
              connections.push({ from: 'primary', to: id });
            }
          });
          if (nodes.slm) {
            connections.push({ from: 'primary', to: 'slm' });
          }
          drawConnections(connections);
        }
      });
      
      canvas.addEventListener('mouseup', () => {
        draggedNode = null;
      });
    }

    // WebSocket for real-time updates
    function initWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
      
      ws.onopen = () => {
        const status = document.getElementById('ws-status');
        status.classList.add('live');
        status.innerHTML = '<div class="dot"></div><span>Live</span>';
      };
      
      ws.onclose = () => {
        const status = document.getElementById('ws-status');
        status.classList.remove('live');
        status.innerHTML = '<div class="dot"></div><span>Reconnecting...</span>';
        setTimeout(initWebSocket, 2000);
      };
      
      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        
        // Handle different event types
        if (msg.event === 'subagent:created' || msg.event === 'subagent:updated' || msg.event === 'subagent:deleted') {
          // Refresh architecture on subagent changes
          fetchArchitecture();
        }
        
        if (msg.event === 'activity:new' || msg.event === 'usage:new') {
          // Subtle updates without full refresh
          // Could update context usage, status indicators, etc.
        }
      };
    }

    // Utility: Format numbers
    function formatNumber(num) {
      if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
      if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
      return num.toString();
    }

    // Auto-refresh every 30 seconds
    setInterval(fetchArchitecture, 30000);

    // Start
    init();
  </script>
</body>
</html>
