<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard â€” Agent Portal</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0f;
      --surface: rgba(255,255,255,0.04);
      --surface-hover: rgba(255,255,255,0.07);
      --border: rgba(255,255,255,0.08);
      --text: #e4e4e7;
      --text-muted: #71717a;
      --text-dim: #52525b;
      --accent: #818cf8;
      --accent-dim: rgba(129,140,248,0.15);
      --green: #34d399;
      --green-dim: rgba(52,211,153,0.15);
      --yellow: #fbbf24;
      --yellow-dim: rgba(251,191,36,0.15);
      --red: #f87171;
      --red-dim: rgba(248,113,113,0.15);
      --blue: #60a5fa;
      --blue-dim: rgba(96,165,250,0.15);
      --purple: #a78bfa;
      --purple-dim: rgba(167,139,250,0.15);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', system-ui, sans-serif; background: var(--bg); color: var(--text); height: 100vh; overflow: hidden; display: flex; flex-direction: column; }

    /* Header & Navigation */
    header {
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid var(--border);
      position: sticky; 
      top: 0; 
      z-index: 50;
      background: rgba(10,10,15,0.85); 
      backdrop-filter: blur(12px);
      flex-shrink: 0;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    
    .logo { 
      font-size: 1.1rem; 
      font-weight: 600; 
      display: flex; 
      align-items: center; 
      gap: 0.5rem; 
    }
    
    .logo a {
      color: var(--text);
      text-decoration: none;
    }
    
    .logo a:hover {
      color: var(--accent);
    }
    
    .nav-links {
      display: flex;
      gap: 0.25rem;
    }
    
    .nav-link {
      font-size: 0.85rem;
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      color: var(--text-muted);
      text-decoration: none;
      transition: all 0.15s;
      font-weight: 500;
    }
    
    .nav-link:hover {
      background: var(--surface-hover);
      color: var(--text);
    }
    
    .nav-link.active {
      background: var(--accent-dim);
      color: var(--accent);
    }
    
    .header-right { display: flex; align-items: center; gap: 0.75rem; }
    .user { display: flex; align-items: center; gap: 0.5rem; }
    .user img { width: 28px; height: 28px; border-radius: 50%; }
    .user span { font-size: 0.8rem; color: var(--text-muted); }
    .btn-s { font-size: 0.75rem; padding: 0.3rem 0.6rem; border-radius: 6px; border: 1px solid var(--border); background: transparent; color: var(--text-muted); cursor: pointer; text-decoration: none; }
    .btn-s:hover { background: var(--surface-hover); color: var(--text); }

    /* Avatar fallback */
    .avatar { width: 28px; height: 28px; border-radius: 50%; overflow: hidden; flex-shrink: 0; }
    .avatar img { width: 100%; height: 100%; object-fit: cover; }
    .avatar-fallback { width: 28px; height: 28px; border-radius: 50%; background: var(--accent-dim); color: var(--accent); display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 600; }

    /* Main Layout */
    .dashboard-layout {
      display: grid;
      grid-template-columns: 60% 40%;
      gap: 0;
      height: calc(100vh - 49px);
      overflow: hidden;
    }

    .left-panel {
      border-right: 1px solid var(--border);
      overflow-y: auto;
      padding: 1.5rem;
    }

    .right-panel {
      overflow-y: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Scheduled Tasks */
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .section-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
    }

    .last-updated {
      font-size: 0.7rem;
      color: var(--text-dim);
      font-family: 'JetBrains Mono', monospace;
    }

    .task-group {
      margin-bottom: 2rem;
    }

    .group-title {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .group-count {
      font-size: 0.65rem;
      color: var(--text-dim);
      background: var(--surface);
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
    }

    .task-card {
      background: var(--surface);
      border: 2px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 0.75rem;
      transition: all 0.15s;
    }

    .task-card:hover {
      background: var(--surface-hover);
    }

    .task-card.ok {
      border-color: var(--green);
    }

    .task-card.overdue {
      border-color: var(--yellow);
    }

    .task-card.error {
      border-color: var(--red);
    }

    .task-card.disabled {
      border-color: var(--border);
      opacity: 0.6;
    }

    .task-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.75rem;
    }

    .task-title {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text);
      line-height: 1.4;
    }

    .task-status {
      font-size: 0.65rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      flex-shrink: 0;
    }

    .task-status.ok {
      background: var(--green-dim);
      color: var(--green);
    }

    .task-status.error {
      background: var(--red-dim);
      color: var(--red);
    }

    .task-status.overdue {
      background: var(--yellow-dim);
      color: var(--yellow);
    }

    .task-meta {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.4rem 1rem;
      font-size: 0.75rem;
      font-family: 'JetBrains Mono', monospace;
    }

    .task-meta-label {
      color: var(--text-dim);
    }

    .task-meta-value {
      color: var(--text-muted);
      text-align: right;
    }

    .task-outcome {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--border);
      font-size: 0.8rem;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .empty {
      text-align: center;
      padding: 2rem;
      color: var(--text-dim);
      font-size: 0.85rem;
    }

    .empty .icon {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    /* Collapsible */
    .collapsible-header {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .collapsible-header::before {
      content: 'â–¼';
      font-size: 0.6rem;
      transition: transform 0.2s;
    }

    .collapsible-header.collapsed::before {
      transform: rotate(-90deg);
    }

    .collapsible-content {
      max-height: 1000px;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }

    .collapsible-content.collapsed {
      max-height: 0;
    }

    /* Chat Panel */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .chat-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text);
    }

    .conn {
      font-size: 0.7rem;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .conn .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
      transition: all 0.2s;
    }

    .conn.connected .status-dot {
      background: var(--green);
      box-shadow: 0 0 6px var(--green);
    }

    .conn.connected {
      color: var(--text-muted);
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      scroll-behavior: smooth;
    }

    .messages::-webkit-scrollbar {
      width: 8px;
    }

    .messages::-webkit-scrollbar-track {
      background: transparent;
    }

    .messages::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .message {
      display: flex;
      gap: 0.75rem;
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent-dim);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--accent);
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: var(--surface);
      color: var(--text);
    }

    .message-content {
      max-width: 70%;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .message.user .message-content {
      align-items: flex-end;
    }

    .message-bubble {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0.75rem 1rem;
      font-size: 0.9rem;
      line-height: 1.5;
      color: var(--text);
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user .message-bubble {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
      font-weight: 500;
    }

    .message-timestamp {
      font-size: 0.7rem;
      color: var(--text-dim);
      padding: 0 0.5rem;
    }

    .message.assistant.loading .message-bubble {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.85rem 1.25rem;
    }

    .typing-indicator {
      display: flex;
      gap: 0.35rem;
    }

    .typing-indicator span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-muted);
      animation: bounce 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes bounce {
      0%, 60%, 100% {
        transform: translateY(0);
      }
      30% {
        transform: translateY(-8px);
      }
    }

    .input-area {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      background: var(--bg);
      flex-shrink: 0;
    }

    .input-wrapper {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .input-box {
      flex: 1;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 0.75rem 1rem;
      font-family: inherit;
      font-size: 0.9rem;
      color: var(--text);
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      transition: all 0.15s;
    }

    .input-box:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--surface-hover);
    }

    .input-box::placeholder {
      color: var(--text-dim);
    }

    .send-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: var(--accent);
      color: #000;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .send-btn:hover:not(:disabled) {
      filter: brightness(1.15);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .chat-empty {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      padding: 2rem;
      text-align: center;
    }

    .chat-empty .icon {
      font-size: 3rem;
      opacity: 0.3;
    }

    .chat-empty h2 {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .chat-empty p {
      font-size: 0.9rem;
      color: var(--text-dim);
      max-width: 400px;
      line-height: 1.5;
    }

    /* Responsive */
    @media (max-width: 968px) {
      .dashboard-layout {
        grid-template-columns: 1fr;
        grid-template-rows: 60% 40%;
      }

      .left-panel {
        border-right: none;
        border-bottom: 1px solid var(--border);
      }

      .user span {
        display: none;
      }
    }
  </style>
<script>
  !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init capture register register_once register_for_session unregister unregister_for_session getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey getNextSurveyStep identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty createPersonProfile opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing debug getPageviewId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
  posthog.init('phc_QBrEydH4duDZXg7OeNTpOrCb2lB77yn1S54FrnCt8Pp',{api_host:'https://analytics.mtree.io',person_profiles:'identified_only'})
</script>
</head>
<body>
  <header>
    <div class="header-left">
      <div class="logo">
        <a href="/">ðŸ¦ž Talos</a>
      </div>
      <nav class="nav-links">
        <a href="/dashboard" class="nav-link active">Dashboard</a>
        <a href="/architecture" class="nav-link">Architecture</a>
      </nav>
    </div>
    <div class="header-right">
      <div class="user" id="user-info">
        <div class="avatar" id="user-avatar"></div>
        <span id="user-name"></span>
      </div>
      <a href="/auth/logout" class="btn-s">Logout</a>
    </div>
  </header>

  <div class="dashboard-layout">
    <!-- Left Panel: Scheduled Tasks -->
    <div class="left-panel">
      <div class="section-header">
        <h1 class="section-title">ðŸ“… Scheduled Tasks</h1>
        <div class="last-updated" id="last-updated">â€”</div>
      </div>

      <!-- Recurring -->
      <div class="task-group" id="recurring-group">
        <div class="group-title collapsible-header" onclick="toggleGroup('recurring')">
          Recurring
          <span class="group-count" id="recurring-count">0</span>
        </div>
        <div class="collapsible-content" id="recurring-content"></div>
      </div>

      <!-- Upcoming One-shots -->
      <div class="task-group" id="oneshots-group">
        <div class="group-title collapsible-header" onclick="toggleGroup('oneshots')">
          Upcoming One-shots
          <span class="group-count" id="oneshots-count">0</span>
        </div>
        <div class="collapsible-content" id="oneshots-content"></div>
      </div>

      <!-- Disabled/Completed -->
      <div class="task-group" id="disabled-group">
        <div class="group-title collapsible-header collapsed" onclick="toggleGroup('disabled')">
          Disabled/Completed
          <span class="group-count" id="disabled-count">0</span>
        </div>
        <div class="collapsible-content collapsed" id="disabled-content"></div>
      </div>
    </div>

    <!-- Right Panel: Chat -->
    <div class="right-panel">
      <div class="chat-container">
        <div class="chat-header">
          <h2 class="chat-title">ðŸ’¬ Chat</h2>
          <div class="conn" id="connection-status">
            <span class="status-dot"></span>
            <span class="status-text">Connecting...</span>
          </div>
        </div>

        <div class="messages" id="messages">
          <div class="chat-empty">
            <div class="icon">ðŸ’¬</div>
            <h2>Start a conversation</h2>
            <p>Ask me anything! I'm connected to your OpenClaw gateway.</p>
          </div>
        </div>

        <div class="input-area">
          <div class="input-wrapper">
            <textarea 
              class="input-box" 
              id="message-input" 
              placeholder="Type a message..." 
              rows="1"
              maxlength="10000"></textarea>
            <button class="send-btn" id="send-btn" onclick="sendMessage()">
              âž¤
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========== Scheduled Tasks ==========
    let scheduledTasks = [];
    let refreshInterval = null;

    async function init() {
      await loadUser();
      await loadScheduledTasks();
      await initChat();
      // Refresh scheduled tasks every 60 seconds
      refreshInterval = setInterval(loadScheduledTasks, 60000);
      // Update relative times every 10 seconds
      setInterval(updateRelativeTimes, 10000);
    }

    async function loadUser() {
      const r = await fetch('/api/me');
      const u = await r.json();
      if (u) {
        const avatarEl = document.getElementById('user-avatar');
        const nameEl = document.getElementById('user-name');
        nameEl.textContent = u.name || u.email;

        if (u.picture) {
          const img = document.createElement('img');
          img.src = u.picture;
          img.alt = u.name || '';
          img.referrerPolicy = 'no-referrer';
          img.onerror = () => {
            avatarEl.innerHTML = '';
            avatarEl.appendChild(makeAvatarFallback(u.name || u.email));
          };
          avatarEl.appendChild(img);
        } else {
          avatarEl.appendChild(makeAvatarFallback(u.name || u.email));
        }
      }
    }

    function makeAvatarFallback(name) {
      const div = document.createElement('div');
      div.className = 'avatar-fallback';
      const initials = (name || '?').split(' ').map(w => w[0]).slice(0, 2).join('').toUpperCase();
      div.textContent = initials;
      return div;
    }

    async function loadScheduledTasks() {
      try {
        const res = await fetch('/api/scheduled-tasks');
        const data = await res.json();
        scheduledTasks = data.tasks || [];
        
        if (data.updatedAt) {
          const lastUpdated = new Date(data.updatedAt);
          document.getElementById('last-updated').textContent = 'Updated ' + formatRelativeTime(lastUpdated);
        }

        renderScheduledTasks();
      } catch (err) {
        console.error('Failed to load scheduled tasks:', err);
      }
    }

    function renderScheduledTasks() {
      const now = new Date();
      
      // Categorize tasks
      const recurring = [];
      const oneshots = [];
      const disabled = [];

      scheduledTasks.forEach(task => {
        if (!task.enabled) {
          disabled.push(task);
        } else if (task.schedule.kind === 'at') {
          oneshots.push(task);
        } else {
          recurring.push(task);
        }
      });

      // Sort oneshots by date
      oneshots.sort((a, b) => new Date(a.nextRunAt) - new Date(b.nextRunAt));

      // Render each group
      renderTaskGroup('recurring', recurring);
      renderTaskGroup('oneshots', oneshots);
      renderTaskGroup('disabled', disabled);

      // Update counts
      document.getElementById('recurring-count').textContent = recurring.length;
      document.getElementById('oneshots-count').textContent = oneshots.length;
      document.getElementById('disabled-count').textContent = disabled.length;
    }

    function renderTaskGroup(groupId, tasks) {
      const container = document.getElementById(`${groupId}-content`);
      
      if (tasks.length === 0) {
        container.innerHTML = '<div class="empty"><div class="icon">ðŸ“­</div>No tasks</div>';
        return;
      }

      container.innerHTML = tasks.map(task => {
        const borderClass = getTaskBorderClass(task);
        const statusClass = getTaskStatusClass(task);
        const statusText = getTaskStatusText(task);

        return `<div class="task-card ${borderClass}">
          <div class="task-header">
            <div class="task-title">${esc(task.name)}</div>
            <div class="task-status ${statusClass}">${statusText}</div>
          </div>
          <div class="task-meta">
            <div class="task-meta-label">Schedule:</div>
            <div class="task-meta-value">${esc(task.scheduleHuman || 'Unknown')}</div>
            <div class="task-meta-label">Last ran:</div>
            <div class="task-meta-value">${task.lastRunAt ? formatRelativeTime(new Date(task.lastRunAt)) : 'Never'}</div>
            <div class="task-meta-label">Next run:</div>
            <div class="task-meta-value">${task.nextRunAt ? formatRelativeTime(new Date(task.nextRunAt)) : 'â€”'}</div>
          </div>
          ${task.lastOutcome ? `<div class="task-outcome">${esc(task.lastOutcome)}</div>` : ''}
        </div>`;
      }).join('');
    }

    function getTaskBorderClass(task) {
      if (!task.enabled) return 'disabled';
      if (task.lastStatus === 'error' || task.lastStatus === 'failed') return 'error';
      
      // Check if overdue
      if (task.nextRunAt) {
        const nextRun = new Date(task.nextRunAt);
        if (nextRun < new Date()) return 'overdue';
      }
      
      if (task.lastStatus === 'ok' || task.lastStatus === 'completed') return 'ok';
      return '';
    }

    function getTaskStatusClass(task) {
      if (task.lastStatus === 'error' || task.lastStatus === 'failed') return 'error';
      
      // Check if overdue
      if (task.nextRunAt) {
        const nextRun = new Date(task.nextRunAt);
        if (nextRun < new Date()) return 'overdue';
      }
      
      if (task.lastStatus === 'ok' || task.lastStatus === 'completed') return 'ok';
      return '';
    }

    function getTaskStatusText(task) {
      if (task.lastStatus === 'error' || task.lastStatus === 'failed') return 'Error';
      
      // Check if overdue
      if (task.nextRunAt) {
        const nextRun = new Date(task.nextRunAt);
        if (nextRun < new Date()) return 'Overdue';
      }
      
      if (task.lastStatus === 'ok' || task.lastStatus === 'completed') return 'OK';
      return 'â€”';
    }

    function formatRelativeTime(date) {
      const now = new Date();
      const diffMs = date - now;
      const diffMins = Math.floor(Math.abs(diffMs) / 60000);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      const isPast = diffMs < 0;

      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return `${isPast ? '' : 'in '}${diffMins} minute${diffMins > 1 ? 's' : ''}${isPast ? ' ago' : ''}`;
      if (diffHours < 24) return `${isPast ? '' : 'in '}${diffHours} hour${diffHours > 1 ? 's' : ''}${isPast ? ' ago' : ''}`;
      if (diffDays < 7) return `${isPast ? '' : 'in '}${diffDays} day${diffDays > 1 ? 's' : ''}${isPast ? ' ago' : ''}`;
      
      // Format as date
      if (isPast) {
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      } else {
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
      }
    }

    function updateRelativeTimes() {
      renderScheduledTasks();
    }

    function toggleGroup(groupId) {
      const header = document.querySelector(`#${groupId}-group .collapsible-header`);
      const content = document.getElementById(`${groupId}-content`);
      
      header.classList.toggle('collapsed');
      content.classList.toggle('collapsed');
    }

    function esc(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    // ========== Chat ==========
    let ws = null;
    let reconnectTimer = null;
    let reconnectAttempts = 0;
    let isWaitingForResponse = false;
    let currentUser = null;
    let gatewayConfig = null;
    let currentRunId = null;

    const messagesContainer = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const connectionStatus = document.getElementById('connection-status');

    async function initChat() {
      await loadChatConfig();
      connectWebSocket();
      setupInputListeners();
    }

    async function loadChatConfig() {
      try {
        const res = await fetch('/api/chat-config');
        gatewayConfig = await res.json();
      } catch (err) { console.error('Failed to load chat config:', err); }
    }

    function connectWebSocket() {
      updateConnectionStatus('reconnecting', 'Connecting...');
      if (!gatewayConfig || !gatewayConfig.gatewayWsUrl) {
        updateConnectionStatus('error', 'Not configured');
        return;
      }
      try {
        let wsUrl = gatewayConfig.gatewayWsUrl;
        if (wsUrl.startsWith('http')) wsUrl = wsUrl.replace(/^http/, 'ws');
        else if (!wsUrl.includes('://')) wsUrl = 'wss://' + wsUrl;

        ws = new WebSocket(wsUrl);
        ws.onopen = () => {};
        ws.onmessage = (event) => {
          try { handleMessage(JSON.parse(event.data)); }
          catch (err) { console.error('Parse error:', err); }
        };
        ws.onerror = (err) => console.error('WS error:', err);
        ws.onclose = (event) => {
          updateConnectionStatus('error', 'Disconnected');
          if (isWaitingForResponse) {
            isWaitingForResponse = false;
            removeLoadingIndicator();
          }
          scheduleReconnect();
        };
      } catch (err) {
        updateConnectionStatus('error', 'Failed');
        scheduleReconnect();
      }
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectAttempts++;
      const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
      reconnectTimer = setTimeout(() => { reconnectTimer = null; connectWebSocket(); }, delay);
    }

    function wsSend(data) {
      if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(data));
    }

    function handleMessage(data) {
      if (data.event === 'connect.challenge') {
        wsSend({
          type: 'req', id: 'connect-1', method: 'connect',
          params: {
            minProtocol: 3, maxProtocol: 3,
            client: { id: 'webchat-ui', version: '1.0.0', platform: 'web', mode: 'webchat' },
            role: 'operator',
            auth: { token: gatewayConfig.gatewayToken },
            userAgent: 'agent-portal-chat/1.0'
          }
        });
        return;
      }

      if (data.type === 'res') {
        if (data.id === 'connect-1') {
          if (data.ok) {
            reconnectAttempts = 0;
            updateConnectionStatus('connected', 'Connected');
            wsSend({ type: 'req', id: 'hist-1', method: 'chat.history', params: { sessionKey: 'agent:main:main' } });
          } else {
            updateConnectionStatus('error', 'Auth failed');
          }
          return;
        }
        if (data.id === 'hist-1') {
          const msgs = data.payload?.messages || [];
          clearMessages();
          msgs.forEach(msg => {
            if (msg.role === 'user' || msg.role === 'assistant') {
              const content = extractText(msg.content);
              if (content) addMessage(msg.role, content, msg.timestamp);
            }
          });
          return;
        }
        if (data.ok && data.payload?.status === 'started') {
          currentRunId = data.payload.runId;
          return;
        }
        return;
      }

      if (data.event === 'chat') {
        const payload = data.payload || data.data || data;
        const state = payload.state;
        const msg = payload.message;

        if (state === 'error') {
          removeLoadingIndicator();
          isWaitingForResponse = false;
          currentRunId = null;
          return;
        }

        if (msg && msg.role === 'assistant') {
          const content = extractText(msg.content);
          if (content) {
            removeLoadingIndicator();
            if (state === 'delta') {
              updateStreamingMessage(content);
            } else {
              finalizeStreamingMessage(content);
              isWaitingForResponse = false;
              currentRunId = null;
            }
          }
        }

        if (state === 'final' && !msg) {
          removeLoadingIndicator();
          isWaitingForResponse = false;
          currentRunId = null;
        }
        return;
      }
    }

    function extractText(content) {
      if (typeof content === 'string') return content;
      if (Array.isArray(content)) return content.filter(c => c.type === 'text').map(c => c.text).join('\n');
      return '';
    }

    function clearMessages() { 
      messagesContainer.innerHTML = ''; 
    }

    function addMessage(role, content, timestamp) {
      const emptyState = messagesContainer.querySelector('.chat-empty');
      if (emptyState) emptyState.remove();

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ' + role;

      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.textContent = role === 'user' ? (currentUser?.name?.[0] || 'T') : 'ðŸ¦ž';

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';

      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = content;

      const time = document.createElement('div');
      time.className = 'message-timestamp';
      time.textContent = formatTimestamp(timestamp || new Date().toISOString());

      contentDiv.appendChild(bubble);
      contentDiv.appendChild(time);
      messageDiv.appendChild(avatar);
      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      scrollToBottom();
    }

    function updateStreamingMessage(content) {
      let el = document.getElementById('streaming-message');
      if (!el) {
        const emptyState = messagesContainer.querySelector('.chat-empty');
        if (emptyState) emptyState.remove();
        el = document.createElement('div');
        el.className = 'message assistant';
        el.id = 'streaming-message';
        el.innerHTML = '<div class="message-avatar">ðŸ¦ž</div><div class="message-content"><div class="message-bubble"></div></div>';
        messagesContainer.appendChild(el);
      }
      el.querySelector('.message-bubble').textContent = content;
      scrollToBottom();
    }

    function finalizeStreamingMessage(content) {
      const el = document.getElementById('streaming-message');
      if (el) {
        el.removeAttribute('id');
        el.querySelector('.message-bubble').textContent = content;
        const time = document.createElement('div');
        time.className = 'message-timestamp';
        time.textContent = formatTimestamp(new Date().toISOString());
        el.querySelector('.message-content').appendChild(time);
        scrollToBottom();
      } else {
        addMessage('assistant', content);
      }
    }

    function addLoadingIndicator() {
      const div = document.createElement('div');
      div.className = 'message assistant loading';
      div.id = 'loading-indicator';
      div.innerHTML = '<div class="message-avatar">ðŸ¦ž</div><div class="message-content"><div class="message-bubble"><div class="typing-indicator"><span></span><span></span><span></span></div></div></div>';
      messagesContainer.appendChild(div);
      scrollToBottom();
    }

    function removeLoadingIndicator() {
      const el = document.getElementById('loading-indicator');
      if (el) el.remove();
      if (window._responseTimeout) { clearTimeout(window._responseTimeout); window._responseTimeout = null; }
    }

    function scrollToBottom() { messagesContainer.scrollTop = messagesContainer.scrollHeight; }

    function formatTimestamp(iso) {
      const d = new Date(iso), now = new Date(), diff = now - d;
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return Math.floor(diff/60000) + 'm ago';
      if (d.toDateString() === now.toDateString()) return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      if (diff < 604800000) return d.toLocaleDateString('en-US', { weekday: 'short', hour: 'numeric', minute: '2-digit', hour12: true });
      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
    }

    function updateConnectionStatus(state, text) {
      connectionStatus.className = 'conn ' + state;
      connectionStatus.querySelector('.status-text').textContent = text;
    }

    function setupInputListeners() {
      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      });
      messageInput.addEventListener('input', () => {
        messageInput.style.height = 'auto';
        messageInput.style.height = messageInput.scrollHeight + 'px';
      });
    }

    function sendMessage() {
      const text = messageInput.value.trim();
      if (!text || isWaitingForResponse) return;
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      addMessage('user', text);
      const sendId = 'send-' + Date.now();
      wsSend({ type: 'req', id: sendId, method: 'chat.send', params: { sessionKey: 'agent:main:main', message: text, idempotencyKey: sendId } });
      addLoadingIndicator();
      isWaitingForResponse = true;
      messageInput.value = '';
      messageInput.style.height = 'auto';
      sendBtn.disabled = true;
      setTimeout(() => { sendBtn.disabled = false; }, 500);
      if (window._responseTimeout) clearTimeout(window._responseTimeout);
      window._responseTimeout = setTimeout(() => {
        if (isWaitingForResponse) {
          isWaitingForResponse = false;
          removeLoadingIndicator();
        }
      }, 120000);
    }

    // Start
    init();
  </script>
</body>
</html>
