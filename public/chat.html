<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat - Agent Portal</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0f;
      --surface: rgba(255,255,255,0.04);
      --surface-hover: rgba(255,255,255,0.07);
      --border: rgba(255,255,255,0.08);
      --text: #e4e4e7;
      --text-muted: #71717a;
      --text-dim: #52525b;
      --accent: #818cf8;
      --accent-dim: rgba(129,140,248,0.15);
      --green: #34d399;
      --yellow: #fbbf24;
      --red: #f87171;
      --blue: #60a5fa;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Embed mode ‚Äî hide header when inside iframe */
    body.embed-mode header { display: none; }

    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
      border-bottom: 1px solid var(--border);
      background: rgba(10,10,15,0.85);
      backdrop-filter: blur(12px);
      flex-shrink: 0;
    }

    .logo {
      font-size: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .logo .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--green);
      box-shadow: 0 0 8px var(--green);
    }

    .nav-links { display: flex; gap: 0.25rem; }
    .nav-link {
      font-size: 0.85rem; padding: 0.4rem 0.75rem; border-radius: 6px;
      color: var(--text-muted); text-decoration: none; transition: all 0.15s; font-weight: 500;
    }
    .nav-link:hover { background: var(--surface-hover); color: var(--text); }
    .nav-link.active { background: var(--accent-dim); color: var(--accent); }

    .header-right {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .conn {
      font-size: 0.7rem;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .conn .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
      transition: all 0.2s;
    }

    .conn.connected .status-dot {
      background: var(--green);
      box-shadow: 0 0 6px var(--green);
    }

    .conn.connected {
      color: var(--text-muted);
    }

    .conn.reconnecting .status-dot {
      background: var(--yellow);
      box-shadow: 0 0 6px var(--yellow);
    }

    .conn.error .status-dot {
      background: var(--red);
      box-shadow: 0 0 6px var(--red);
    }

    .user {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .user img {
      width: 28px;
      height: 28px;
      border-radius: 50%;
    }

    .user span {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .btn-s {
      font-size: 0.75rem;
      padding: 0.3rem 0.6rem;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      text-decoration: none;
      transition: all 0.15s;
    }

    .btn-s:hover {
      background: var(--surface-hover);
      color: var(--text);
    }

    /* Chat Container */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      overflow: hidden;
    }

    /* Messages */
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      scroll-behavior: smooth;
    }

    .messages::-webkit-scrollbar {
      width: 8px;
    }

    .messages::-webkit-scrollbar-track {
      background: transparent;
    }

    .messages::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    .messages::-webkit-scrollbar-thumb:hover {
      background: var(--surface);
    }

    .message {
      display: flex;
      gap: 0.75rem;
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent-dim);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--accent);
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: var(--surface);
      color: var(--text);
    }

    .message-content {
      max-width: 70%;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .message.user .message-content {
      align-items: flex-end;
    }

    .message-bubble {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0.75rem 1rem;
      font-size: 0.9rem;
      line-height: 1.5;
      color: var(--text);
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user .message-bubble {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
      font-weight: 500;
    }

    .message-timestamp {
      font-size: 0.7rem;
      color: var(--text-dim);
      padding: 0 0.5rem;
    }

    /* Message status badges */
    .message-status {
      font-size: 0.65rem;
      padding: 0 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-family: 'JetBrains Mono', monospace;
    }
    .message-status.sending {
      color: var(--accent);
    }
    .message-status.queued {
      color: var(--yellow);
    }
    .message-status .status-icon {
      display: inline-block;
      width: 6px; height: 6px;
      border-radius: 50%;
      background: currentColor;
    }
    .message-status.sending .status-icon {
      animation: pulse-status 1.2s infinite;
    }
    @keyframes pulse-status {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* Queue banner */
    .queue-banner {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.4rem 1rem;
      background: rgba(251,191,36,0.08);
      border-top: 1px solid rgba(251,191,36,0.2);
      font-size: 0.75rem;
      color: var(--yellow);
      font-family: 'JetBrains Mono', monospace;
    }
    .queue-banner .queue-dots span {
      display: inline-block;
      width: 4px; height: 4px;
      border-radius: 50%;
      background: var(--yellow);
      margin: 0 2px;
      animation: bounce 1.4s infinite;
    }
    .queue-banner .queue-dots span:nth-child(2) { animation-delay: 0.2s; }
    .queue-banner .queue-dots span:nth-child(3) { animation-delay: 0.4s; }

    /* Loading indicator */
    .message.assistant.loading .message-bubble {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.85rem 1.25rem;
    }

    .typing-indicator {
      display: flex;
      gap: 0.35rem;
    }

    .typing-indicator span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-muted);
      animation: bounce 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes bounce {
      0%, 60%, 100% {
        transform: translateY(0);
      }
      30% {
        transform: translateY(-8px);
      }
    }

    /* Input Area */
    .input-area {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border);
      background: var(--bg);
      flex-shrink: 0;
    }

    .input-wrapper {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
      max-width: 900px;
      margin: 0 auto;
    }

    .input-box {
      flex: 1;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 0.75rem 1rem;
      font-family: inherit;
      font-size: 0.9rem;
      color: var(--text);
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      transition: all 0.15s;
    }

    .input-box:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--surface-hover);
    }

    .input-box::placeholder {
      color: var(--text-dim);
    }

    .send-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: var(--accent);
      color: #000;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .send-btn:hover:not(:disabled) {
      filter: brightness(1.15);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Empty State */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      padding: 2rem;
      text-align: center;
    }

    .empty-state .icon {
      font-size: 3rem;
      opacity: 0.3;
    }

    .empty-state h2 {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .empty-state p {
      font-size: 0.9rem;
      color: var(--text-dim);
      max-width: 400px;
      line-height: 1.5;
    }

    /* Error Banner */
    .error-banner {
      background: rgba(248, 113, 113, 0.1);
      border: 1px solid var(--red);
      border-radius: 10px;
      padding: 0.75rem 1rem;
      margin: 1rem 1.5rem 0;
      display: none;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.85rem;
      color: var(--red);
    }

    .error-banner.show {
      display: flex;
    }

    .error-banner .icon {
      font-size: 1.25rem;
    }

    .error-banner .close {
      margin-left: auto;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.15s;
    }

    .error-banner .close:hover {
      opacity: 1;
    }

    /* Attachment button */
    .attach-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .attach-btn:hover {
      background: var(--surface-hover);
      color: var(--text);
      border-color: var(--accent);
    }

    /* Image preview area */
    #image-preview-area {
      max-width: 900px;
      margin: 0 auto 0.5rem;
      padding: 0 1.5rem;
      display: none;
    }

    .preview-thumb {
      position: relative;
      display: inline-block;
    }

    .preview-thumb img {
      max-width: 150px;
      max-height: 100px;
      border-radius: 8px;
      border: 1px solid var(--border);
      display: block;
    }

    .preview-thumb .remove-btn {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: none;
      background: var(--red);
      color: #fff;
      cursor: pointer;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      font-weight: 700;
    }

    /* Chat images in bubbles */
    .chat-image {
      max-width: 300px;
      border-radius: 10px;
      display: block;
      margin: 4px 0;
      cursor: pointer;
      transition: opacity 0.15s;
    }

    .chat-image:hover {
      opacity: 0.88;
    }

    .message.user .chat-image {
      border: 1px solid rgba(255,255,255,0.15);
    }

    .message.assistant .chat-image {
      border: 1px solid var(--border);
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .messages {
        padding: 1rem;
      }

      .message-content {
        max-width: 85%;
      }

      .input-area {
        padding: 0.75rem 1rem;
      }

      #image-preview-area {
        padding: 0 1rem;
      }

      .user span {
        display: none;
      }
    }
  </style>
<script>
  !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init capture register register_once register_for_session unregister unregister_for_session getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey getNextSurveyStep identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty createPersonProfile opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing debug getPageviewId".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
  posthog.init('phc_QBrEydH4duDZXg7OeNTpOrCb2lB77yn1S54FrnCt8Pp',{api_host:'https://analytics.mtree.io',person_profiles:'identified_only'})
</script>
</head>
<body>
  <script>
    // Embed mode detection: query param OR iframe
    if (new URLSearchParams(location.search).get('embed') === '1' || window !== window.top) {
      document.body.classList.add('embed-mode');
    }
  </script>
  <!-- Header -->
  <header>
    <div style="display:flex;align-items:center;gap:1.5rem;">
      <div class="logo">
        <span class="dot"></span>
        <a href="/" style="color:var(--text);text-decoration:none;font-weight:700;">ü¶û Talos</a>
      </div>
      <nav class="nav-links">
        <a href="/dashboard" class="nav-link">Dashboard</a>
        <a href="/architecture" class="nav-link">Architecture</a>
        <a href="/docs" class="nav-link">Docs</a>
        <a href="/c" class="nav-link active">Chat</a>
        <a href="/game" class="nav-link">üéÆ Game Assets</a>
      </nav>
    </div>
    <div class="header-right">
      <div class="conn" id="connection-status">
        <span class="status-dot"></span>
        <span class="status-text">Connecting...</span>
      </div>
      <div class="user" id="user-info">
        <img src="" alt="" id="user-avatar" style="display: none;">
        <span id="user-name"></span>
      </div>
      <button class="btn-s" onclick="logout()">Logout</button>
    </div>
  </header>

  <!-- Error Banner -->
  <div class="error-banner" id="error-banner">
    <span class="icon">‚ö†Ô∏è</span>
    <span class="message" id="error-message"></span>
    <span class="close" onclick="hideError()">‚úï</span>
  </div>

  <!-- Chat Container -->
  <div class="chat-container">
    <div class="messages" id="messages">
      <div class="empty-state">
        <div class="icon">üí¨</div>
        <h2>Start a conversation</h2>
        <p>Ask me anything! I'm connected to your OpenClaw gateway and ready to help.</p>
      </div>
    </div>

    <div class="input-area">
      <!-- Hidden file input for image selection -->
      <input type="file" id="file-input" accept="image/*" style="display:none;" onchange="handleFileSelect(event)">
      <!-- Image preview above input box -->
      <div id="image-preview-area"></div>
      <div class="input-wrapper">
        <button class="attach-btn" onclick="openFilePicker()" title="Attach image">üìé</button>
        <textarea 
          class="input-box" 
          id="message-input" 
          placeholder="Type a message..." 
          rows="1"
          maxlength="10000"></textarea>
        <button class="send-btn" id="send-btn" onclick="sendMessage()">
          ‚û§
        </button>
      </div>
    </div>
  </div>

  <script>
    // Extract JWT from URL param for embedded auth
    const urlParams = new URLSearchParams(window.location.search);
    const jwtToken = urlParams.get('token');
    // Clean token from URL without reload
    if (jwtToken) {
      const cleanUrl = window.location.pathname + '?embed=1';
      window.history.replaceState({}, '', cleanUrl);
    }

    // State
    let ws = null;
    let reconnectTimer = null;
    let reconnectAttempts = 0;
    let isWaitingForResponse = false;
    let currentUser = null;
    let gatewayConfig = null;
    let currentRunId = null;
    let messageQueue = []; // queued messages to send after current response
    let pendingImage = null; // { dataUrl, mimeType } ‚Äî selected but not yet sent

    const messagesContainer = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const connectionStatus = document.getElementById('connection-status');
    const errorBanner = document.getElementById('error-banner');
    const errorMessage = document.getElementById('error-message');

    // Debug log - POST errors to server for remote debugging
    const debugLog = [];
    function dbg(msg, data) {
      const entry = { ts: new Date().toISOString(), msg, data };
      debugLog.push(entry);
      console.log('[chat-debug]', msg, data || '');
      // POST debug info to server
      fetch('/api/chat-debug', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...(jwtToken ? { 'Authorization': 'Bearer ' + jwtToken } : {}) },
        body: JSON.stringify(entry)
      }).catch(() => {});
    }

    async function init() {
      await loadUser();
      await loadConfig();
      dbg('init', { wsUrl: gatewayConfig?.gatewayWsUrl?.substring(0, 60), hasToken: !!gatewayConfig?.gatewayToken });
      connectWebSocket();
      setupInputListeners();
    }

    async function loadUser() {
      try {
        const headers = jwtToken ? { 'Authorization': 'Bearer ' + jwtToken } : {};
        const res = await fetch('/api/me', { headers });
        currentUser = await res.json();
        if (currentUser) {
          document.getElementById('user-name').textContent = currentUser.name || currentUser.email;
          if (currentUser.picture) {
            const avatar = document.getElementById('user-avatar');
            avatar.src = currentUser.picture;
            avatar.style.display = 'block';
          }
        }
      } catch (err) { console.error('Failed to load user:', err); }
    }

    async function loadConfig() {
      try {
        const headers = jwtToken ? { 'Authorization': 'Bearer ' + jwtToken } : {};
        const res = await fetch('/api/chat-config?_t=' + Date.now(), { headers, cache: 'no-store' });
        gatewayConfig = await res.json();
        console.log('[chat] config loaded:', { wsUrl: gatewayConfig?.gatewayWsUrl, hasToken: !!gatewayConfig?.gatewayToken, hasDevice: gatewayConfig?.hasDeviceIdentity });
      } catch (err) { console.error('Failed to load config:', err); }
    }

    function connectWebSocket() {
      updateConnectionStatus('reconnecting', 'Connecting...');
      if (!gatewayConfig || !gatewayConfig.gatewayWsUrl) {
        showError('Gateway not configured.');
        updateConnectionStatus('error', 'Not configured');
        return;
      }
      try {
        // Use server-side WebSocket proxy instead of direct gateway connection
        // This avoids Tailscale Funnel reachability issues from the browser
        let wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/gateway';

        console.log('[chat] connecting to:', wsUrl);
        ws = new WebSocket(wsUrl);
        ws.binaryType = 'arraybuffer';
        ws.onopen = () => { console.log('[chat] ws-open'); dbg('ws-open'); };
        ws.onmessage = (event) => {
          try {
            const text = typeof event.data === 'string' ? event.data : new TextDecoder().decode(event.data);
            handleMessage(JSON.parse(text));
          } catch (err) { console.error('Parse error:', err); }
        };
        ws.onerror = (err) => console.error('[chat] WS error:', err, 'readyState:', ws?.readyState);
        ws.onclose = (event) => {
          console.log('WS closed:', event.code, event.reason);
          updateConnectionStatus('error', 'Disconnected');
          // Reset send lock so chat doesn't freeze after reconnect
          if (isWaitingForResponse) {
            isWaitingForResponse = false;
            removeLoadingIndicator();
          }
          scheduleReconnect();
        };
      } catch (err) {
        showError('Connection failed: ' + err.message);
        updateConnectionStatus('error', 'Failed');
        scheduleReconnect();
      }
    }

    function scheduleReconnect() {
      if (reconnectTimer) return;
      reconnectAttempts++;
      const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
      updateConnectionStatus('reconnecting', 'Reconnecting in ' + Math.round(delay/1000) + 's...');
      reconnectTimer = setTimeout(() => { reconnectTimer = null; connectWebSocket(); }, delay);
    }

    function wsSend(data) {
      if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(data));
      else showError('Not connected');
    }

    function handleMessage(data) {
      dbg('ws-msg', { event: data.event || data.type, ok: data.ok, error: data.error?.message, state: data.payload?.state });

      // Challenge-response auth (OpenClaw gateway protocol)
      if (data.event === 'connect.challenge') {
        dbg('auth-challenge');
        const nonce = data.payload?.nonce || '';
        (async () => {
          const connectParams = {
            minProtocol: 3, maxProtocol: 3,
            client: { id: 'webchat-ui', version: '1.0.0', platform: 'web', mode: 'webchat' },
            role: 'operator',
            scopes: ['operator.read', 'operator.write', 'operator.admin'],
            auth: { token: gatewayConfig.gatewayToken },
            userAgent: 'agent-portal-chat/1.0'
          };
          // Get server-signed device identity with nonce
          if (gatewayConfig.hasDeviceIdentity) {
            try {
              const signResp = await fetch('/api/chat-sign', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ nonce }),
                credentials: 'same-origin'
              });
              const signData = await signResp.json();
              if (signData.device) {
                connectParams.device = signData.device;
                dbg('using-device-identity', { deviceId: signData.device.id, hasNonce: !!nonce });
              } else {
                dbg('device-sign-failed', signData.error);
              }
            } catch (e) {
              dbg('device-sign-error', e.message);
            }
          }
          wsSend({ type: 'req', id: 'connect-1', method: 'connect', params: connectParams });
        })();
        return;
      }

      // RPC responses
      if (data.type === 'res') {
        if (!data.ok && data.error) {
          console.error('RPC error:', data.id, data.error);
          if (data.id !== 'connect-1' && data.id !== 'hist-1' && data.id !== 'sub-1') {
            showError(data.error.message || 'Request failed');
            removeLoadingIndicator();
            isWaitingForResponse = false;
          }
        }
        if (data.id === 'connect-1') {
          if (data.ok) {
            reconnectAttempts = 0;
            updateConnectionStatus('connected', 'Connected');
            hideError();
            wsSend({ type: 'req', id: 'hist-1', method: 'chat.history', params: { sessionKey: 'agent:main:main' } });
            // CRITICAL: Subscribe to chat events to receive push updates
            wsSend({ type: 'req', id: 'sub-1', method: 'chat.subscribe', params: { sessionKey: 'agent:main:main' } });
          } else {
            const err = data.error?.message || 'Auth failed';
            if (err.includes('pairing')) {
              const reqId = data.error?.details?.requestId;
              showError(`Device pairing required. ${reqId ? 'Request ID: ' + reqId + '. ' : ''}Waiting for approval...`);
              updateConnectionStatus('error', 'Pairing required');
              // Auto-retry after 5s in case pairing gets approved
              setTimeout(() => { if (ws) { ws.close(); connectWebSocket(); } }, 5000);
            } else {
              showError(err);
              updateConnectionStatus('error', 'Auth failed');
            }
          }
          return;
        }
        if (data.id === 'hist-1') {
          const msgs = (data.payload?.messages || []).slice();
          // Sort by timestamp to ensure correct display order
          msgs.sort((a, b) => {
            const ta = a.timestamp ? new Date(a.timestamp).getTime() : 0;
            const tb = b.timestamp ? new Date(b.timestamp).getTime() : 0;
            return ta - tb;
          });
          clearMessages();
          msgs.forEach(msg => {
            // Skip system messages
            if (msg.role === 'system') return;
            
            if (msg.role === 'user' || msg.role === 'assistant') {
              const content = extractText(msg.content);
              if (!content) return;
              
              // Filter tool noise from user messages
              if (msg.role === 'user') {
                if (content.startsWith('Read HEARTBEAT.md') || 
                    content.startsWith('System:') || 
                    content.startsWith('[media attached:') || 
                    content.startsWith('Pre-compaction memory') ||
                    content.includes('HEARTBEAT_OK') ||
                    content.includes('NO_REPLY')) {
                  return;
                }
              }
              
              // Filter tool noise from assistant messages
              if (msg.role === 'assistant') {
                if (content === 'NO_REPLY' || 
                    content === 'HEARTBEAT_OK' ||
                    content.includes('Read image file') ||
                    content.includes('(no output)') ||
                    content.includes('Process still running') ||
                    content.includes('Command still running') ||
                    content.includes('Process exited')) {
                  return;
                }
              }
              
              addMessage(msg.role, content, msg.timestamp);
            }
          });
          return;
        }
        // chat.send ack
        if (data.ok && data.payload?.status === 'started') {
          currentRunId = data.payload.runId;
          return;
        }
        return;
      }

      // Streaming chat event ‚Äî assistant reply (delta or final)
      if (data.event === 'chat') {
        const payload = data.payload || data.data || data;
        const state = payload.state; // 'delta', 'final', or 'error'
        const msg = payload.message;
        console.log('[chat-event]', state, msg?.role, msg?.content?.substring?.(0, 50) || '');

        if (state === 'error') {
          removeLoadingIndicator();
          showError(payload.errorMessage || 'Agent error');
          isWaitingForResponse = false;
          currentRunId = null;
          processQueue();
          return;
        }

        // Handle user message echo from subscription ‚Äî ensure it appears
        // BEFORE the assistant response (fixes response-above-question bug)
        if (msg && msg.role === 'user') {
          const content = extractText(msg.content);
          if (content && !isWaitingForResponse) {
            // Only add if this message isn't already in the DOM (sent from another surface like iMessage)
            const existingMsgs = messagesContainer.querySelectorAll('.message.user .message-bubble');
            const isDuplicate = Array.from(existingMsgs).some(el => el.textContent === content);
            if (!isDuplicate) {
              addMessage('user', content, msg.timestamp);
            }
          }
          // Don't return ‚Äî fall through in case state is also 'final'
        }

        if (msg && msg.role === 'assistant') {
          const content = extractText(msg.content);
          if (content) {
            // Ensure the loading indicator (which sits after the user message)
            // is removed before we add the response
            removeLoadingIndicator();
            if (state === 'delta') {
              updateStreamingMessage(content);
            } else {
              // final or unrecognized state ‚Äî finalize
              finalizeStreamingMessage(content);
              isWaitingForResponse = false;
              currentRunId = null;
              processQueue();
            }
          }
        }

        if (state === 'final' && (!msg || (msg.role !== 'assistant' && msg.role !== 'user'))) {
          // final with no actionable message (e.g. empty response)
          removeLoadingIndicator();
          isWaitingForResponse = false;
          currentRunId = null;
          processQueue();
        }
        return;
      }

      // Ignore non-chat events
      if (data.event) return;

      // Error
      if (data.error) {
        showError(typeof data.error === 'string' ? data.error : data.error.message || 'Unknown error');
        removeLoadingIndicator();
        isWaitingForResponse = false;
        processQueue();
      }
    }

    function extractText(content) {
      let text = '';
      if (typeof content === 'string') {
        text = content;
      } else if (Array.isArray(content)) {
        text = content.filter(c => c.type === 'text').map(c => c.text).join('\n');
      }
      
      // Filter tool noise patterns from streaming content
      if (text) {
        // Skip messages with tool output patterns
        const toolPatterns = [
          'Read image file',
          '(no output)',
          'Process still running',
          'Command still running',
          'Process exited',
          'HEARTBEAT_OK',
          'NO_REPLY'
        ];
        
        for (const pattern of toolPatterns) {
          if (text.includes(pattern)) {
            return ''; // Filter out entirely if it contains tool noise
          }
        }
      }
      
      return text;
    }

    function clearMessages() { messagesContainer.innerHTML = ''; }

    function addMessage(role, content, timestamp, statusType) {
      const emptyState = messagesContainer.querySelector('.empty-state');
      if (emptyState) emptyState.remove();

      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ' + role;

      const avatar = document.createElement('div');
      avatar.className = 'message-avatar';
      avatar.textContent = role === 'user' ? (currentUser?.name?.[0] || 'T') : 'ü¶û';

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';

      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      renderMessageContent(bubble, content, role);

      const time = document.createElement('div');
      time.className = 'message-timestamp';
      time.textContent = formatTimestamp(timestamp || new Date().toISOString());

      contentDiv.appendChild(bubble);

      // Status badge for user messages
      if (role === 'user' && statusType) {
        const status = document.createElement('div');
        status.className = 'message-status ' + statusType;
        status.innerHTML = `<span class="status-icon"></span>${statusType === 'sending' ? 'Sending‚Ä¶' : 'Queued'}`;
        contentDiv.appendChild(status);
        messageDiv._statusEl = status;
      } else {
        contentDiv.appendChild(time);
      }

      messageDiv.appendChild(avatar);
      messageDiv.appendChild(contentDiv);
      messagesContainer.appendChild(messageDiv);
      scrollToBottom();
      return messageDiv;
    }

    function updateStreamingMessage(content) {
      let el = document.getElementById('streaming-message');
      if (!el) {
        const emptyState = messagesContainer.querySelector('.empty-state');
        if (emptyState) emptyState.remove();
        el = document.createElement('div');
        el.className = 'message assistant';
        el.id = 'streaming-message';
        el.innerHTML = '<div class="message-avatar">ü¶û</div><div class="message-content"><div class="message-bubble"></div></div>';
        messagesContainer.appendChild(el);
      }
      const bubble = el.querySelector('.message-bubble');
      bubble.innerHTML = '';
      renderMessageContent(bubble, content, 'assistant');
      scrollToBottom();
    }

    function finalizeStreamingMessage(content) {
      const el = document.getElementById('streaming-message');
      if (el) {
        el.removeAttribute('id');
        const bubble = el.querySelector('.message-bubble');
        bubble.innerHTML = '';
        renderMessageContent(bubble, content, 'assistant');
        // Add timestamp
        const time = document.createElement('div');
        time.className = 'message-timestamp';
        time.textContent = formatTimestamp(new Date().toISOString());
        el.querySelector('.message-content').appendChild(time);
        scrollToBottom();
      } else {
        addMessage('assistant', content);
      }
    }

    function addLoadingIndicator() {
      const div = document.createElement('div');
      div.className = 'message assistant loading';
      div.id = 'loading-indicator';
      div.innerHTML = '<div class="message-avatar">ü¶û</div><div class="message-content"><div class="message-bubble"><div class="typing-indicator"><span></span><span></span><span></span></div></div></div>';
      messagesContainer.appendChild(div);
      scrollToBottom();
    }

    function removeLoadingIndicator() {
      const el = document.getElementById('loading-indicator');
      if (el) el.remove();
      if (window._responseTimeout) { clearTimeout(window._responseTimeout); window._responseTimeout = null; }
    }

    function scrollToBottom() { messagesContainer.scrollTop = messagesContainer.scrollHeight; }

    function formatTimestamp(iso) {
      const d = new Date(iso), now = new Date(), diff = now - d;
      if (diff < 60000) return 'Just now';
      if (diff < 3600000) return Math.floor(diff/60000) + 'm ago';
      if (d.toDateString() === now.toDateString()) return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
      if (diff < 604800000) return d.toLocaleDateString('en-US', { weekday: 'short', hour: 'numeric', minute: '2-digit', hour12: true });
      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true });
    }

    function updateConnectionStatus(state, text) {
      connectionStatus.className = 'conn ' + state;
      connectionStatus.querySelector('.status-text').textContent = text;
    }

    function showError(msg) { errorMessage.textContent = msg; errorBanner.classList.add('show'); }
    function hideError() { errorBanner.classList.remove('show'); }

    function setupInputListeners() {
      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      });
      messageInput.addEventListener('input', () => {
        messageInput.style.height = 'auto';
        messageInput.style.height = messageInput.scrollHeight + 'px';
      });
    }

    // ‚îÄ‚îÄ‚îÄ Image handling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    function openFilePicker() {
      document.getElementById('file-input').click();
    }

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        pendingImage = { dataUrl: ev.target.result, mimeType: file.type };
        showImagePreview(ev.target.result);
      };
      reader.readAsDataURL(file);
      e.target.value = ''; // reset so same file can be re-selected
    }

    function showImagePreview(dataUrl) {
      const area = document.getElementById('image-preview-area');
      area.style.display = 'block';
      area.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'preview-thumb';
      const img = document.createElement('img');
      img.src = dataUrl;
      const btn = document.createElement('button');
      btn.className = 'remove-btn';
      btn.textContent = '‚úï';
      btn.onclick = clearImagePreview;
      wrap.appendChild(img);
      wrap.appendChild(btn);
      area.appendChild(wrap);
    }

    function clearImagePreview() {
      pendingImage = null;
      const area = document.getElementById('image-preview-area');
      area.style.display = 'none';
      area.innerHTML = '';
    }

    /**
     * Render message content into a bubble element.
     * Detects:
     *   [image:data:image/...;base64,...] ‚Äî inline base64 image (user or assistant)
     *   MEDIA: <url>                      ‚Äî media URL in assistant messages
     */
    function renderMessageContent(bubble, content, role) {
      // Patterns
      const imgTagRe = /\[image:(data:[^\]]+)\]/g;
      const mediaRe = /MEDIA:\s*(\S+)/g;

      const matches = [];
      let m;

      imgTagRe.lastIndex = 0;
      while ((m = imgTagRe.exec(content)) !== null) {
        matches.push({ start: m.index, end: m.index + m[0].length, src: m[1] });
      }

      if (role === 'assistant') {
        mediaRe.lastIndex = 0;
        while ((m = mediaRe.exec(content)) !== null) {
          matches.push({ start: m.index, end: m.index + m[0].length, src: m[1] });
        }
      }

      if (matches.length === 0) {
        bubble.textContent = content;
        return;
      }

      bubble.innerHTML = '';
      matches.sort((a, b) => a.start - b.start);

      let pos = 0;
      for (const match of matches) {
        // Text before image
        if (match.start > pos) {
          const textSpan = document.createElement('span');
          textSpan.style.whiteSpace = 'pre-wrap';
          textSpan.textContent = content.slice(pos, match.start);
          bubble.appendChild(textSpan);
        }
        // Image element
        const img = document.createElement('img');
        img.className = 'chat-image';
        img.src = match.src;
        img.alt = 'Image';
        img.title = 'Click to view full size';
        img.onclick = () => window.open(match.src, '_blank');
        img.onerror = () => {
          const err = document.createElement('span');
          err.textContent = '[Image failed to load]';
          err.style.color = 'var(--red)';
          img.replaceWith(err);
        };
        bubble.appendChild(img);
        pos = match.end;
      }

      // Remaining text
      if (pos < content.length) {
        const textSpan = document.createElement('span');
        textSpan.style.whiteSpace = 'pre-wrap';
        textSpan.textContent = content.slice(pos);
        bubble.appendChild(textSpan);
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    let activeUserMsg = null; // track the message being processed
    let queuedUserMsgs = []; // track queued message elements

    function sendMessage() {
      const text = messageInput.value.trim();
      const image = pendingImage;
      if (!text && !image) return;
      if (!ws || ws.readyState !== WebSocket.OPEN) { showError('Not connected'); return; }

      messageInput.value = '';
      messageInput.style.height = 'auto';

      // Build full message content (text + optional inline image)
      let fullContent = text;
      if (image) {
        const imageTag = `[image:${image.dataUrl}]`;
        fullContent = text ? text + '\n' + imageTag : imageTag;
        clearImagePreview();
      }

      if (isWaitingForResponse) {
        // Show as queued
        const msgEl = addMessage('user', fullContent, null, 'queued');
        messageQueue.push({ text: fullContent, el: msgEl });
        queuedUserMsgs.push(msgEl);
        updateQueueIndicator();
        return;
      }

      // Show as sending
      const msgEl = addMessage('user', fullContent, null, 'sending');
      activeUserMsg = msgEl;
      dispatchMessage(fullContent);
    }

    function dispatchMessage(text) {
      const sendId = 'send-' + Date.now();
      wsSend({ type: 'req', id: sendId, method: 'chat.send', params: { sessionKey: 'agent:main:main', message: text, idempotencyKey: sendId } });
      addLoadingIndicator();
      isWaitingForResponse = true;
      // Safety timeout: unlock after 120s if no response received
      if (window._responseTimeout) clearTimeout(window._responseTimeout);
      window._responseTimeout = setTimeout(() => {
        if (isWaitingForResponse) {
          isWaitingForResponse = false;
          removeLoadingIndicator();
          markMessageDone(activeUserMsg);
          console.warn('Response timeout ‚Äî unlocking chat input');
          processQueue();
        }
      }, 120000);
    }

    function markMessageDone(msgEl) {
      if (!msgEl || !msgEl._statusEl) return;
      const parent = msgEl._statusEl.parentNode;
      const time = document.createElement('div');
      time.className = 'message-timestamp';
      time.textContent = formatTimestamp(new Date().toISOString());
      parent.replaceChild(time, msgEl._statusEl);
      delete msgEl._statusEl;
    }

    function processQueue() {
      // Mark the completed message as done
      markMessageDone(activeUserMsg);
      activeUserMsg = null;

      updateQueueIndicator();
      if (messageQueue.length > 0 && !isWaitingForResponse) {
        const next = messageQueue.shift();
        // Promote from queued ‚Üí sending
        if (next.el && next.el._statusEl) {
          next.el._statusEl.className = 'message-status sending';
          next.el._statusEl.innerHTML = '<span class="status-icon"></span>Sending‚Ä¶';
        }
        activeUserMsg = next.el;
        queuedUserMsgs = queuedUserMsgs.filter(m => m !== next.el);
        updateQueueIndicator();
        dispatchMessage(next.text);
      }
    }

    function updateQueueIndicator() {
      let banner = document.getElementById('queue-banner');
      if (messageQueue.length > 0) {
        if (!banner) {
          banner = document.createElement('div');
          banner.id = 'queue-banner';
          banner.className = 'queue-banner';
          const inputArea = document.querySelector('.input-area');
          inputArea.parentNode.insertBefore(banner, inputArea);
        }
        banner.innerHTML = `<span class="queue-dots"><span></span><span></span><span></span></span> ${messageQueue.length} message${messageQueue.length > 1 ? 's' : ''} queued`;
      } else if (banner) {
        banner.remove();
      }
    }

    function logout() { window.location.href = '/auth/logout'; }

    init();
  </script>
</body>
</html>
